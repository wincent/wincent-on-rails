#!/usr/bin/env ruby
# See "How To Write a UNIX Daemon" by Dave Lennert
# http://cjh.polyplex.org/software/daemon.pdf

# can override environment from command line:
#   RAILS_ENV=development script/daemon
ENV['RAILS_ENV'] ||= 'production'

require 'pathname'
require Pathname.new(__FILE__).dirname + '..' + 'config' + 'environment'

# configuration
SLEEP_INTERVAL  = 15 # seconds
PID_FILE        = Rails.root + 'tmp' + 'daemon.pid'
LOG_FILE        = Rails.root + 'log' + 'daemon.log'

def daemonize
  # no need to detach if launched by init/launchd process
  unless Process.ppid == 1  # unfortunately, this is a race

    # ignore terminal stop signals
    trap 'TTOU', 'IGNORE'
    trap 'TTIN', 'IGNORE'
    trap 'TSTP', 'IGNORE'

    # allow parent shell to continue
    fork and exit         # ensure process is not a process group leader

    # disassociate from controlling terminal and process group
    Process.setsid        # lose controlling terminal, change process group
    trap 'HUP', 'IGNORE'  # become immune from process group leader death
    fork and exit         # become non-process group leader
  end

  # close all file descriptors
  ObjectSpace.each_object(IO) do |io|
    io.close unless io.closed?
  end
  Dir.chdir '/' # move current directory off mounted filesystem
  File.umask 0  # clear any inherited file mode creation mask
end

def setup_logging
  STDOUT.reopen LOG_FILE, 'a'
  STDOUT.sync = true
  begin
    STDERR.reopen STDOUT # seems to always raise #<IOError: closed stream>
  rescue
    STDERR.reopen LOG_FILE, 'a'
  end
  STDERR.sync = true
end

def log msg
  time  = Time.now
  pid   = Process.pid
  msg.split("\n", -1).each do |line|
    puts "#{time} script/daemon[#{pid}]: #{line}"
  end
end

def log_and_abort msg
  log "#{msg} (aborting)"
  exit 1
end

def check_pid_file
  # yes, there is a race here; we double-check later
  if File.exist? PID_FILE
    log_and_abort "pid file already exists at #{PID_FILE}"
  end
end

def create_pid_file
  log "will create pid file #{PID_FILE}"

  # here we catch the possible race
  File.open(PID_FILE, File::CREAT | File::EXCL | File::WRONLY) do |f|
    f.puts Process.pid
  end
  log "did create pid file #{PID_FILE}"
  at_exit do
    log "will remove pid file #{PID_FILE}"
    File.delete PID_FILE
    log "did remove pid file #{PID_FILE}"
  end
rescue Errno::EEXIST
  log_and_abort "pid file already exists at #{PID_FILE}"
end

def wake_up_and_work
  log 'working'
end

check_pid_file
daemonize
setup_logging
create_pid_file

begin
  $running = true
  trap 'TERM' do
    log "received SIGTERM, will schedule shutdown for within #{SLEEP_INTERVAL} seconds"
    $running = false
  end
  log 'entering processing loop'
  while $running do
    wake_up_and_work
    sleep SLEEP_INTERVAL
  end
  log 'shutting down'
rescue Exception => e
  log "uncaught exception: #{e.class}: #{e.message}; backtrace follows\n"
  e.backtrace.each do |frame|
    log "    #{frame}"
  end
  log_and_abort "\n"
end

