#!/bin/sh -e

# base settings:
# note that we don't specify users, but rely on per-host defaults from
# ~/.ssh/config
REPO=/pub/git/private/wincent.com.git
ADMIN_HOST=wincent1.inetu.net

# default settings for production environment:
SERVER=rails.wincent.com
MONIT_GROUP=production
BRANCH=maint
DEPLOY=/home/rails.wincent.com/deploy
ENVIRONMENT=production

staging_environment_overrides() {
  SERVER=kreacher.wincent.com
  MONIT_GROUP=staging
  BRANCH=master
  DEPLOY=/home/kreacher.wincent.com/deploy
  ENVIRONMENT=staging
}

bail() {
  echo $1
  exit 1
}

usage() {
  echo "Usage:"
  echo "  $0 [options] command..."
  echo ""
  echo "Deployment commands:"
  echo "        unlock    loosen permissions to enable deployment"
  echo "         check    check dependencies and prerequisites"
  echo "        deploy    clone repo and deploy"
  echo "  migrate_test    migrate test database only"
  echo "          spec    run specs"
  echo "       disable    display a maintenance page"
  echo "       migrate    migrate all databases"
  echo "        switch    update the symlink to point to the latest deployment"
  echo "       restart    restart cluster (changes go live)"
  echo "        enable    remove maintenance page"
  echo "      lockdown    tighten permissions after deployment"
  echo ""
  echo "Other commands:"
  echo "        upload    upload comma-separated files specified in FILES environment variable"
  echo ""
  echo "Options:"
  echo "     --staging    deploy to staging environment (can abbreviate to \"staging\")"
  echo "     --rev=REF    deploy tag (eg. \"0.7\"), branch (eg. \"origin/maint\"), commit (SHA1)"
  echo ""
  echo "Example workflow:"
  echo "     # note how commands can be chained together:"
  echo "     $0 staging unlock check deploy migrate_test spec"
  echo "     $0 staging disable migrate switch restart enable lockdown"
  echo ""
  echo "     # now we repeat in the production environment:"
  echo "     $0 unlock check deploy migrate_test spec"
  echo "     $0 disable migrate switch restart enable lockdown"
  echo ""
  echo "     # the \"prep/finalize\" shorthand encapsulates the above patterns:"
  echo "     $0 staging prep"
  echo "     $0 staging finalize"
  echo "     $0 prep"
  echo "     $0 finalize"
  echo ""
  echo "     # the \"all\" shorthand is the same as \"prep\" then \"finalize\""
  echo "     $0 staging all"
  echo "     $0 all"
  exit
}

#
# main
#

# process arguments
while test $# != 0; do
  case "$1" in
    -h|--help|help)
      usage
      ;;
    --staging|staging|--stage|stage)
      staging_environment_overrides
      ;;
    --rev=*)
      test -z "$REF" || echo "warn: multiple revision arguments passed"
      REF="${1#--rev=}"
      ;;
    --revision=*)
      test -z "$REF" || echo "warn: multiple revision arguments passed"
      REF="${1#--revision=}"
      ;;
    unlock)
      DO_UNLOCK=true
      ;;
    wait) # undocumented but helpful to wait for "unlock" to take effect
      DO_WAIT=true
      ;;
    check)
      DO_CHECK=true
      ;;
    deploy)
      DO_DEPLOY=true
      ;;
    migrate_test)
      DO_MIGRATE_TEST=true
      ;;
    spec)
      DO_SPEC=true
      ;;
    disable)
      DO_DISABLE=true
      ;;
    migrate)
      DO_MIGRATE=true
      ;;
    switch)
      DO_SWITCH=true
      ;;
    stop)  # not advertised in usage
      DO_STOP=true
      ;;
    start) # not advertised in usage
      DO_START=true
      ;;
    restart)
      DO_RESTART=true
      ;;
    enable)
      DO_ENABLE=true
      ;;
    lockdown)
      DO_LOCKDOWN=true
      ;;
    upload)
      DO_UPLOAD=true
      ;;
    prep)
      DO_UNLOCK=true
      DO_WAIT=true
      DO_CHECK=true
      DO_DEPLOY=true
      DO_MIGRATE_TEST=true
      DO_SPEC=true
      ;;
    finalize)
      DO_DISABLE=true
      DO_MIGRATE=true
      DO_SWITCH=true
      DO_RESTART=true
      DO_ENABLE=true
      DO_LOCKDOWN=true
      ;;
    all)
      DO_UNLOCK=true
      DO_WAIT=true
      DO_CHECK=true
      DO_DEPLOY=true
      DO_MIGRATE_TEST=true
      DO_SPEC=true
      DO_DISABLE=true
      DO_MIGRATE=true
      DO_SWITCH=true
      DO_RESTART=true
      DO_ENABLE=true
      DO_LOCKDOWN=true
      ;;
    *)
      usage
      ;;
  esac
  shift
done

# make sure the user asked us to at least do something
test -n "$DO_UNLOCK" \
  -o -n "$DO_WAIT" \
  -o -n "$DO_CHECK" \
  -o -n "$DO_DEPLOY" \
  -o -n "$DO_MIGRATE_TEST" \
  -o -n "$DO_SPEC" \
  -o -n "$DO_DISABLE" \
  -o -n "$DO_MIGRATE" \
  -o -n "$DO_SWITCH" \
  -o -n "$DO_STOP" \
  -o -n "$DO_START" \
  -o -n "$DO_RESTART" \
  -o -n "$DO_ENABLE" \
  -o -n "$DO_UPLOAD" \
  -o -n "$DO_LOCKDOWN" || usage

trap 'test -n "$SUCCESS" || echo "error: aborted"' EXIT

echo "Environment for this session: $ENVIRONMENT"

if [ -n "$DO_UNLOCK" ]; then
   echo "Processing command: unlock (you may be asked for a password)"
   ssh -t $ADMIN_HOST sudo chsh -s /bin/sh $SERVER
fi

# useful because remote system sometimes won't notice "unlock" immediately
if [ -n "$DO_WAIT" ]; then
  echo "Processing command: wait"
  sleep 15
fi

if [ -n "$DO_CHECK" ]; then
  echo "Processing command: check"
  echo "  checking: JavaScript is correctly minimized"
  COMPRESSOR=/usr/local/bin/closure/compiler.jar
  test -f $COMPRESSOR || bail "  failed: compressor not found at $COMPRESSOR"
  test -r $COMPRESSOR || bail "  failed: compressor not readable at $COMPRESSOR"
  TMPDIR=$(mktemp -q -d /private/tmp/deploy.XXXXXX) || bail "  failed: could not create temporary directory"
  if [ -z "$REF" ]; then
    LOCAL_REF=$BRANCH
  else
    LOCAL_REF=$REF
  fi
  for JS in $(ls public/javascripts/*.max.js); do
    git show $LOCAL_REF:$JS > $TMPDIR/max.js
    git show $LOCAL_REF:${JS/.max.js/.min.js} > $TMPDIR/min.js
    java -jar $COMPRESSOR --js=$TMPDIR/max.js --js_output_file=$TMPDIR/out.js
    diff -q $TMPDIR/min.js $TMPDIR/out.js > /dev/null || bail "  failed: $JS is not minimized in $LOCAL_REF"
  done
  echo "  checking: directories exist and are writable"
  ssh $SERVER "sh -c '(test -d $DEPLOY          || (echo \"  failed -d: $DEPLOY\" && exit 1)) && \
                      (test -d $DEPLOY/shared   || (echo \"  failed -d: $DEPLOY/shared\" && exit 1)) && \
                      (test -d $DEPLOY/releases || (echo \"  failed -d: $DEPLOY/releases\" && exit 1)) && \
                      (test -w $DEPLOY          || (echo \"  failed -w: $DEPLOY\" && exit 1)) && \
                      (test -w $DEPLOY/releases || (echo \"  failed -w: $DEPLOY/releases\" && exit 1))'"
  echo "  checking: executables exist"
  ssh $SERVER "sh -l -c 'which gem git > /dev/null'"
  echo "  checking: gem versions"
  ssh $SERVER "sh -c 'gem specification --version \">= 0.6\"   hpricot > /dev/null && \
                      gem specification --version \">= 1.3.1\" rubygems-update > /dev/null && \
                      gem specification --version \">= 1.0.0\" rack > /dev/null && \
                      gem specification --version \">= 1.0\" mkdtemp > /dev/null'"
  echo "  checking: local branch vs remote branch"
  git diff --exit-code --quiet $BRANCH origin/$BRANCH || \
    echo "  warning: local $BRANCH differs from remote origin/$BRANCH: did you remember to 'git push'?"
  echo "  checking: currently checked out branch"
  CURRENT_BRANCH=$(git symbolic-ref HEAD 2> /dev/null)
  CURRENT_BRANCH=${CURRENT_BRANCH#refs/heads/}
  test "$CURRENT_BRANCH" = "$BRANCH" || \
    echo "  warning: currently on branch $CURRENT_BRANCH (expected $BRANCH) -- sure you're working on the right branch?"
fi

if [ -n "$DO_DEPLOY" ]; then
  echo "Processing command: deploy"
  TIMESTAMP=$(date '+%Y%m%d%H%M%S')
  echo "  timestamp: $TIMESTAMP"
  SHARED=$DEPLOY/shared
  CHECKOUT=$DEPLOY/releases/$TIMESTAMP
  if [ -z "$REF" ]; then
    REMOTE_REF=origin/$BRANCH
  else
    REMOTE_REF=$REF
  fi
  ssh $SERVER "sh -l -c '(test ! -e $TIMESTAMP || (echo \"  failed: $CHECKOUT already exists\" && exit 1)) && \
                      git clone --shared $REPO $CHECKOUT && \
                      cd $CHECKOUT && \
                      git checkout -b deploy $REMOTE_REF && \
                      (git rev-parse HEAD > $CHECKOUT/REVISION) && \
                      rm -rf $CHECKOUT/log \
                             $CHECKOUT/public/system \
                             $CHECKOUT/tmp/pids && \
                      ln -s $SHARED/log    $CHECKOUT/log && \
                      ln -s $SHARED/system $CHECKOUT/public/system && \
                      ln -s $SHARED/pids   $CHECKOUT/tmp/pids && \
                      find $CHECKOUT/public/images \
                           $CHECKOUT/public/stylesheets \
                           $CHECKOUT/public/javascripts \
                           -exec touch {} + && \
                      ln -s $SHARED/database.yml    $CHECKOUT/config/database.yml && \
                      ln -s $SHARED/app_config.yml  $CHECKOUT/config/app_config.yml && \
                      rm -f $DEPLOY/latest && \
                      ln -s $CHECKOUT $DEPLOY/latest && \
                      cd $CHECKOUT && \
                      rake --silent gems:clean && \
                      rake --silent gems:build && \
                      rake --silent js:minify:deploy > /dev/null'"
fi

if [ -n "$DO_MIGRATE_TEST" ]; then
  echo "Processing command: migrate_test"
  ssh $SERVER "sh -c 'cd $DEPLOY/latest && rake --silent RAILS_ENV=test db:migrate'"
fi

if [ -n "$DO_SPEC" ]; then
  echo "Processing command: spec"
  ssh $SERVER "sh -c 'cd $DEPLOY/latest && rake --silent RAILS_ENV=test spec'"
fi

if [ -n "$DO_DISABLE" ]; then
  echo "Processing command: disable"
  ssh $SERVER cp $DEPLOY/current/public/maintenance.html \
                 $DEPLOY/shared/system/maintenance.html
fi

if [ -n "$DO_MIGRATE" ]; then
  echo "Processing command: migrate"
  ssh $SERVER "sh -c 'cd $DEPLOY/latest && \
                      rake --silent RAILS_ENV=test         db:migrate && \
                      rake --silent RAILS_ENV=development  db:migrate && \
                      rake --silent RAILS_ENV=migrations   db:migrate'"
fi

if [ -n "$DO_SWITCH" ]; then
  echo "Processing command: switch"
  LATEST=$DEPLOY/latest
  CURRENT=$DEPLOY/current
  ssh $SERVER "sh -c '(test -d $LATEST || (echo \"  failed: no deployment found at $LATEST\" && exit 1)) && \
                      rm -f $CURRENT && \
                      ln -s $LATEST $CURRENT'"
fi

if [ -n "$DO_STOP" ]; then
  echo "Processing command: stop (you may be asked for a password)"
  ssh -t $ADMIN_HOST "sh -l -c 'sudo monit -g $MONIT_GROUP stop all'"
fi

if [ -n "$DO_RESTART" ]; then
  echo "Processing command: restart (you may be asked for a password)"
  ssh -t $ADMIN_HOST "sh -l -c 'sudo monit -g $MONIT_GROUP restart all'"
fi

if [ -n "$DO_START" ]; then
  echo "Processing command: start (you may be asked for a password)"
  ssh -t $ADMIN_HOST "sh -l -c 'sudo monit -g $MONIT_GROUP start all'"
fi

if [ -n "$DO_ENABLE" ]; then
  echo "Processing command: enable"
  ssh $SERVER rm -f $DEPLOY/shared/system/maintenance.html
fi

if [ -n "$DO_UPLOAD" ]; then
  echo "Processing command: upload"
  test -n "$FILES" || echo "  warning: nothing specified in FILES environment variable"
  (IFS=","
  for FILE in $FILES; do
    echo "  file: $FILE"
    if [[ "$FILE" =~ ' ' ]]; then
      echo "  warning: \"$FILE\" contains a space; skipping"
    else
      scp $FILE $SERVER:$DEPLOY/current/$FILE
    fi
  done)
fi

if [ -n "$DO_LOCKDOWN" ]; then
  echo "Processing command: lockdown (you may be asked for a password)"
  ssh -t $ADMIN_HOST sudo chsh -s /sbin/nologin $SERVER
fi

SUCCESS=true
